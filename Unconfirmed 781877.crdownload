# -*- coding: utf-8 -*-
"""xxx.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13Nyk5iWJaLEBVBQ5bR-JwfTbANGEDwRz
"""

import pandas as pd
import matplotlib.pyplot as plt
from openpyxl import Workbook
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.drawing.image import Image as ExcelImage
import matplotlib.patches as mpatches
from datetime import datetime, timedelta
import ipywidgets as widgets
from IPython.display import display

def input_with_type(prompt, cast_type=str):
    while True:
        try:
            return cast_type(input(f"{prompt}: "))
        except ValueError:
            print("\u274c Invalid input. Try again.")

machines = ['A1', 'A2', 'B1', 'B2', 'C']
machine_groups = {'A': ['A1', 'A2'], 'B': ['B1', 'B2'], 'C': ['C']}
setup_times = {}
orders = []
handling_time = 0
entry_time = []

def input_setup_times():
    print("\n\U0001f527 Enter setup time for each machine (in seconds):")
    for machine in machines:
        setup_times[machine] = input_with_type(f"{machine}", int)

def input_handling_time():
    global handling_time
    handling_time = input_with_type("\nEnter handling time between machines (in sec)", int)

def get_order_entry_datetime():
    print("üìÖ Select Order Entry Date:")

    # Date picker widget
    date_picker = widgets.DatePicker(description='Pick a Date')

    # Time input widget
    time_input = widgets.Text(description='Time (HH:MM:SS):', value='00:00:00')

    display(date_picker, time_input)

    # Wait for user to select date and input time
    while date_picker.value is None or not time_input.value:
        pass  # Loop until both inputs are provided

    # Process the selected date and time
    try:
        full_datetime = datetime.strptime(f"{date_picker.value} {time_input.value}", "%Y-%m-%d %H:%M:%S")
        entry_time.append(full_datetime)  # Store the full datetime
        print(f"‚úÖ Order entry date and time captured: {full_datetime}")
    except Exception as e:
        print(f"‚ùå Error in processing date/time: {e}")
        entry_time.append(None)

def input_orders():
    global orders, machine_availability
    orders = []
    num_orders = input_with_type("\nEnter number of orders", int)
    for i in range(num_orders):
        print(f"\n\U0001f4dd Order {i+1}:")
        quantity = input_with_type("Enter quantity", int)
        due_date = input_with_type("Enter due date (in seconds)", int)

        get_order_entry_datetime()  # Get the order entry datetime
        priority = input_with_type("Enter priority (lower = higher priority)", int)
        group_sequence = input("Enter group sequence (e.g. A,B,C): ").replace(" ", "").split(",")

        machine_sequence = []
        processing_times = []
        prev_end = 0

        for group in group_sequence:
            best_machine = None
            best_start_time = float('inf')

            for m in machine_groups[group]:
                setup = setup_times[m]
                available_time = max(machine_availability[m], prev_end)
                start_time = available_time + setup
                if start_time < best_start_time:
                    best_start_time = start_time
                    best_machine = m

            processing_time = input_with_type(f"Enter processing time for machine {best_machine}", int)
            machine_sequence.append(best_machine)
            processing_times.append(processing_time)
            prev_end = best_start_time + processing_time + handling_time
            machine_availability[best_machine] = prev_end

        orders.append({
            'id': i+1,
            'quantity': quantity,
            'due_date': due_date,
            'priority': priority,
            'machine_sequence': machine_sequence,
            'processing_times': processing_times,
            'entry_time': entry_time[i]
        })

# Initial input
input_setup_times()
machine_availability = {m: 0 for m in machines}
input_handling_time()
input_orders()

# Modified Schedule processing to reduce downtime
full_schedule_records = []
order_completion = {}
machine_usage = {m: 0 for m in machines}
machine_last_end_time = {m: 0 for m in machines}

orders_sorted = sorted(orders, key=lambda x: x['priority'])

for order in orders_sorted:
    prev_machine_end = 0
    for idx, machine in enumerate(order['machine_sequence']):
        setup = setup_times[machine]
        proc_time = order['processing_times'][idx]
        start = max(machine_last_end_time[machine], prev_machine_end)
        start += setup
        end = start + proc_time
        machine_last_end_time[machine] = end + handling_time
        machine_usage[machine] += proc_time
        prev_machine_end = end

        full_schedule_records.append({
            "Order ID": order['id'],
            "Priority": order['priority'],
            "Machine": machine,
            "Start Time (sec)": start,
            "End Time (sec)": end,
        })
    order_completion[order['id']] = prev_machine_end

# Delivery status
for order in orders_sorted:
    completion_time = order_completion[order['id']]
    status = "On time" if completion_time <= order['due_date'] else "Late"
    for rec in full_schedule_records:
        if rec["Order ID"] == order['id']:
            rec["Due Date"] = order['due_date']
            rec["Order Completion"] = completion_time
            rec["Delivery Status"] = status

# Excel creation
wb = Workbook()
ws1 = wb.active
ws1.title = "Schedule"
schedule_df = pd.DataFrame(full_schedule_records)
for r in dataframe_to_rows(schedule_df, index=False, header=True):
    ws1.append(r)

# Idle time
max_completion_time = max(order_completion.values())
ws2 = wb.create_sheet("Idle Time")
ws2.append(["Machine", "Idle Time (sec)"])
for m in machines:
    idle = max_completion_time - machine_usage[m]
    ws2.append([m, idle])

# Summary
total_orders = len(orders)
late_orders = sum(1 for o in orders if order_completion[o['id']] > o['due_date'])
on_time_orders = total_orders - late_orders
avg_lead = sum(order_completion.values()) / total_orders
ws3 = wb.create_sheet("Summary")
summary = [
    ["Metric", "Value"],
    ["Total Production Cost", f"${sum(machine_usage.values()) * 0.5:.2f}"],
    ["Average Lead Time (sec)", avg_lead],
    ["On-time Deliveries", f"{on_time_orders}/{total_orders} ({(on_time_orders/total_orders)*100:.2f}%)"]
]
for row in summary:
    ws3.append(row)

# Order Summary
ws4 = wb.create_sheet("Order Summary")
summary_rows = []
for order in orders_sorted:
    job_steps = [r for r in full_schedule_records if r["Order ID"] == order['id']]
    job_steps.sort(key=lambda x: x["Start Time (sec)"])
    seq = ' ‚Üí '.join([s["Machine"] for s in job_steps])
    start = job_steps[0]["Start Time (sec)"]
    end = job_steps[-1]["End Time (sec)"]
    total = end - start
    completion_datetime = order['entry_time'] + timedelta(seconds=end)
    summary_rows.append({
        "Order ID": order['id'],
        "Priority": order['priority'],
        "Entry Datetime": order['entry_time'].strftime("%Y-%m-%d %H:%M:%S"),
        "Due Date (sec)": order['due_date'],
        "Machine Sequence": seq,
        "Start Time": start,
        "Completion Time": end,
        "Completion Datetime": completion_datetime.strftime("%Y-%m-%d %H:%M:%S"),
        "Total Time (sec)": total,
        "Delivery Status": "On time" if end <= order['due_date'] else "Late"
    })
summary_df = pd.DataFrame(summary_rows)
for r in dataframe_to_rows(summary_df, index=False, header=True):
    ws4.append(r)

# Job Schedule Table
ws5 = wb.create_sheet("Job Schedule Table")
final_job_table = []
for order in orders_sorted:
    job_id = f"J{order['id']}"
    steps = sorted([r for r in full_schedule_records if r["Order ID"] == order['id']], key=lambda x: x["Start Time (sec)"])
    row = {"Job ID": job_id, "Quantity": order['quantity'], "Due Date": order['due_date']}
    for m in machines:
        row[f"{m} In"] = "-"
        row[f"{m} Out"] = "-"
    total_time = 0
    for step in steps:
        m = step["Machine"]
        row[f"{m} In"] = step["Start Time (sec)"]
        row[f"{m} Out"] = step["End Time (sec)"]
        total_time += step["End Time (sec)"] - step["Start Time (sec)"]
    setup_total = sum(setup_times[s["Machine"]] for s in steps)
    handle_total = handling_time * (len(steps) - 1)
    row["Total Time on Machines"] = total_time
    row["Time (Incl Setup+Handling)"] = total_time + setup_total + handle_total
    row["Order Completion Time"] = steps[-1]["End Time (sec)"]
    final_job_table.append(row)

final_df = pd.DataFrame(final_job_table)
for r in dataframe_to_rows(final_df, index=False, header=True):
    ws5.append(r)

# Gantt chart generation
fig, ax = plt.subplots(figsize=(12, 6))
colors = plt.cm.tab20.colors
color_map = {}
patches = []
machine_to_y = {machine: i for i, machine in enumerate(machines)}

for i, record in enumerate(full_schedule_records):
    order_id = record["Order ID"]
    machine = record["Machine"]
    start = record["Start Time (sec)"]
    end = record["End Time (sec)"]

    if order_id not in color_map:
        color = colors[order_id % len(colors)]
        color_map[order_id] = color
        patches.append(mpatches.Patch(color=color, label=f"Order {order_id}"))

    color = color_map[order_id]
    ax.barh(machine_to_y[machine], end - start, left=start, height=0.4, color=color)
    ax.text((start + end)/2, machine_to_y[machine], f"J{order_id}", va='center', ha='center', color='white', fontsize=8)

ax.set_yticks(list(machine_to_y.values()))
ax.set_yticklabels(machines)
ax.set_xlabel("Time (seconds)")
ax.set_title("Gantt Chart: Machine Utilization")
ax.legend(handles=patches, bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.savefig("Gantt_Chart.png")
plt.show()

# Add Gantt chart image